<ul>
  <li>
    <h3>1.1</h3>
    <p>
      так мавпо це штука є базовим декоратором який потрібен для того щоб твій клас став саме котролером в Nest.js  застосунку. 
      Простіше кажучи цей декоратор розширює мета дані твого класу.
      user це префікс він не є обов'язковим,  але допомогає згрупувати пов'язані між собою routes.
    </p>
  </li>
    <li>
      <h3>1.2</h3>
       <p>
     Так бобі напишу одни раз більше повторювати не буду.Декоратор Get() представляює собою звичайний метод HTTP request.
     За аналогією з декоратором Controller в нього можна встановлювати path.В даному випадку він залишається пустим це означає що ми можемо отримати цей route за таким шляхом   /user
    </p>  
    </li>
     <li>
      <h3>1.3</h3>
       <p>
       Так, у Nest.js є два способи для маніпуляції резпонсів.
      1 Standard mode - Коли ми просто повертаємо масив або об'єкти Nest під капотом автоматично серіалізує наші данні до формату JSON.
      Якщо ж ми повертаємо примітиви Javascripta  то Nest надсилає значення примітивів без серіалізації.
      2 Library-specific mode - Ми можемо викорстовувати reposonse об'єкт базуючись на тому на якій платформі ми розробляємо замовчування  це Express.Щоб увімкнути цей мод потрібно використати Res() response.Це дає можливість використовувати нативний  reposonse об'єкт.Наприклад, response.status(200).send()
      </p>  
    </li>
     <li>
      <h3>1.4</h3>
       <p>
        Nest визначає, коли хендлер використовує @Res() або @Next(), що означає, що ви обрали варіант, специфічний для бібліотеки. Якщо обидва підходи застосовані одночасно, стандартний підхід автоматично вимикається для цього конкретного маршруту і більше не працюватиме як очікується.

        Щоб використовувати обидва підходи одночасно (наприклад, коли потрібно лише встановити cookies/заголовки через об’єкт response, але решту залишити фреймворку), необхідно встановити опцію passthrough у значення true в декораторі @Res({ passthrough: true })

        Дивись бобі якщо ти викорстовуєшь Library-specific mode  то тобі обов’язково потрібно надіслати якусь відповідь, викликавши відповідний метод у об’єкта response (наприклад, res.json(...) або res.send(...)), інакше HTTP-сервер зависне.
      </p>  
    </li>
    <li>
      <h3>1.5</h3>
       <p>
       Cтандартний статус-код для відповідей завжди 200, за винятком POST-запитів, для яких за замовчуванням використовується 201.Бобі задопомгою HttpCode декоратора ми можемо змінити цю поведінку.Це одна хуйня типу в нас http status взагалі-то не завжди статичний тому в цьому випадку можна юзати @Res() response та викидувати свій власний статус код наприклад на якусь помилку.
      </p>  
    </li>
</ul>

